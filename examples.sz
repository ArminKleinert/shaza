(import-host "std.string")
(import-host "std.stdio")

; Simple assignment with type induction
(define abc "def")

; Simple assignment
(define ::int defg 1000)

; Simple function definition
(define ::int bar () 1)

; Simple generic void-function
(define (T) baz (::T arg) (writeln arg))

; Testing implicit return
(define ::bool implicit-return-0 () 1)
(define ::bool implicit-return-1 () (llr 1))
(define ::int does-nothing () 123)
(define ::void no-return-on-void () (does-nothing))

; define-fn forces the define to output a function
;   and never a variable.
; <type> <fn> () { return <type>.init; }
(define-fn ::int implicit-init-return-0 () )
(define-fn ::bool implicit-init-return-1 () )

; Test typed assignment with init-value
; bool var = bool.init;
(define ::bool implicit-init-test)

; Test opcall
; auto opcall_test = (1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10);
(define opcall-test (opcall + 1 2 3 4 5 6 7 8 9 10))

; Multiline-comment
(comment
    Everything here is completely ignored.
    This works across lines.)

; Test type-definitions
(def-struct MyType ::int n)
(def-struct MyTypeWithMoreFields ::int m ::int n ::string o ::float p)
(def-struct GenericType (T) ::T entry)
(def-struct EmptyType)

; Test the if statement
(define ::bool if-test ()
    (if #t (return #t) (return #f)))

; recur to function
(define ::void recur-test ()
    (writeln "hey!")
    (recur))

; recur to loop
; FIXME For some reason, the compiler inserts a ; at the end here. Find out why.
(define ::int loop-recur-test ()
    (loop (::int i 0
           v 1)
        (if (ge? i 10)
            (return i)
            (recur (inc i) 15))))

; Test tail-recursion
; TODO Implement
(define ::int tail-recur (::int n ::int res)
    (if (le? n 1)
        (return 1)
        (return (tail-recur-test (dec n) res))))

; Statement as expression
; Treat if as expression and allow for implicit return
; TODO Implement
(define ::int if-as-expression (::int n)
    (if (lt? n 0) (sub 0 n) n))

; Set attribute "n" of object mt
(define ::void setv_attr_test_1 (::MyType mt)
    (setv! mt n 15))

; This one is more of a side-effect of how symbols are parsed. Still nice.
; Notice that this compiles to a simple assignment instead of an
; attribute assignment.
(define ::void setv_attr_test_2 (::MyType mt)
    (setv! mt.n 15))

; Set attribute "n" of object mt; The keyword is turned into a symbol
(define ::void setv_attr_test_3 (::MyType mt)
    (setv! mt :n 15))

; Set attribute "n" of object mt; The string is unquoted.
(define ::void setv_attr_test_4 (::MyType mt)
    (setv! mt "n" 15))

; Tests for character literals
(define chtest1 \tab)
(define chtest2 \space)
(define chtest3 \newline)
(define chtest4 \z)

; Tests for the to-function
(import-host "std.conv")
(define s-to-i-with-base-test (to ::int "12345" 16))
(define s-to-i-test (to ::int "12345"))

; Tests for the cast-function
(define cast-f-i-test (cast ::int 1.5f))

; Lambda tests
(define d (lambda ::int (::int i) (inc i))) ; Assign lambda to a variable
(define ::int call-lambda (::int:delegate(int) l) (l 1)) ; Take lambda as an argument
(define ::void call-call-lambda () (writeln (call-lambda (lambda ::int (::int i) (inc i))))) ; Call function with a lambda

; Lazy argument test
(define ::int give_int_and_print(::int i) (writeln i) i)
(define ::bool or_ (::lazy:int i ::lazy:int j) (llr i || j))
(define ::void docall ()
    (or_ (give_int_and_print 0) (give_int_and_print 1)) ; prints 0 and 1
    (or_ (give_int_and_print 5) (give_int_and_print 9))) ; prints only 5

; New type syntax test
(define ::static:int static-i-0 0)
(define ::"static int" static-i-1 0) ; Same code as the  above
(define ::immutable(int) immutable-i 0) ; Brackets are ok
(define ::int[] int-array []) ; Square brackets are ok
(define ::int* int-pointer null) ; Star is ok

; Simple function with meta info about generics
(meta
  (:generics [T])
  (define ::void baz2 (::T arg) (writeln arg)))
