(import-host "std.string")
(import-host "std.stdio")

(define abc "def")
(define ::int abc 1000)
;(define foo (::int i) ) ; FIXME Compiler thought this was a variable?
(define ::int bar () 1)
(define (T) baz (::T arg) (writeln arg))

(define ::bool (T) eql? (::T o0 ::T o1) (llr o0 == o1))
(define ::bool (T) not_eql? (::T o0 ::T o1) (llr o0 != o1))
(define ::bool (T) lt? (::T o0 ::T o1) (llr o0 < o1))
(define ::bool (T) le? (::T o0 ::T o1) (llr o0 <= o1))
(define ::bool (T) gt? (::T o0 ::T o1) (llr o0 > o1))
(define ::bool (T) ge? (::T o0 ::T o1) (llr o0 >= o1))

(define ::N (N) inc (::N n) (opcall + n 1))
(define ::N (N) dec (::N n) (opcall - n 1))

(define ::T (T) applySelf (::T elem ::"T delegate (T e)" func) (func elem))
(define ::T (T) applyIf
  (::T elem ::T default1 ::"bool delegate (T e)" pred  ::"T delegate (T e)" func)
  (if (pred elem) (return (func elem)) (return default1)))

; A trick: ::" " (important whitespace) can be used to make a define with no type.
;(define ::" " abc "defg") ; FIXME Gave output "abc = abc"???

; Single line comment

(comment
    Everything here is completely ignored.
    This works across lines.)

(def-struct MyType ::int n)
(def-struct MyTypeWithMoreFields ::int m ::int n ::string o ::float p)
(def-struct GenericType (T) ::T entry)
(def-struct EmptyType)

(define ::bool ifTest () {
    (if #t (return #t) (return #f)))

(define ::void infinite_loop ()
    (writeln "hey!")
    (recur))

(define ::int finite_loop ()
    (loop (::int i 0
           v 1)
        (if (ge? i 10)
            (return i)
            (recur (inc i) 15))))
