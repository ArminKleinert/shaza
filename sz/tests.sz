(module tests)

(import-sz stdlib)
(import-host std.functional)

; Helper to find type of basic numbers or strings
(meta (:visibility :private :returns ::string)
  (define typestr (::int i) "int")
  (define typestr (::uint i) "uint")
  (define typestr (::long i) "long")
  (define typestr (::ulong i) "ulong")
  (define typestr (::bool i) "bool")
  (define typestr (::float i) "float")
  (define typestr (::double i) "double")
  (define typestr (::string i) "string"))

(meta (:returns ::bool)

; SECTION Test basic math, bit-operators, comparisons and boolean-stuff

; SUBSECT Test defaults

(define test-defaults ()
  (and
    (= default-int 0)
    (= default-uint 0)
    (= default-long 0)
    (= default-ulong 0)
    (= default-bool #f)
    (= default-float 0.0)
    (= default-double 0.0)
    (= default-string "")))

(define test-default-types ()
  (and
    (= (typestr default-int) "int")
    (= (typestr default-uint) "uint")
    (= (typestr default-long) "long")
    (= (typestr default-ulong) "ulong")
    (= (typestr default-bool) "bool")
    (= (typestr default-float) "float")
    (= (typestr default-double) "double")
    (= (typestr default-string) "string")))

; SUBSECT Test +

(define test-addition ()
  (and
    (= (+ default-int 15) 15)
    (= (+ default-uint 15) 15)
    (= (+ default-long 15) 15)
    (= (+ default-ulong 15) 15)
    (= (+ default-float 15) 15)
    (= (+ default-double 15) 15)))

(define test-addition-2 ()
  (and
    (= (+ default-int 0) 0)
    (= (+ default-uint 0) 0)
    (= (+ default-long 0) 0)
    (= (+ default-ulong 0) 0)
    (= (+ default-float 0) 0)
    (= (+ default-double 0) 0)))

; Test alias
(define test-addition-3 ()
  (= (plus 1000 111) (+ 1000 111)))

(define test-addition-4 ()
  (= (+ 1000 111) (+ 111 1000)))

(define test-addition-types ()
  (and
    (= (typestr (+ default-int 0)) "int")
    (= (typestr (+ default-uint 0)) "uint")
    (= (typestr (+ default-long 0)) "long")
    (= (typestr (+ default-ulong 0)) "ulong")
    (= (typestr (+ default-float 0)) "float")
    (= (typestr (+ default-double 0)) "double")))

; SUBSECT Test -

(define test-subtraction ()
  (and
    (= (- default-int 15) -15)
    (= (- default-long 15) -15)
    (= (- default-float 15) -15)
    (= (- default-double 15) -15)))

(define test-subtraction-2 ()
  (and
    (= (- default-int 0) 0)
    (= (- default-uint 0) 0)
    (= (- default-long 0) 0)
    (= (- default-ulong 0) 0)
    (= (- default-float 0) 0)
    (= (- default-double 0) 0)))

; Test alias
(define test-subtraction-3 ()
  (= (sub 1000 111) (- 1000 111)))

(define test-subtraction-types ()
  (and
    (= (typestr (- default-int 0)) "int")
    (= (typestr (- default-uint 0)) "uint")
    (= (typestr (- default-long 0)) "long")
    (= (typestr (- default-ulong 0)) "ulong")
    (= (typestr (- default-float 0)) "float")
    (= (typestr (- default-double 0)) "double")))

; SUBSECT Test *

(define test-multiplication ()
  (and
    (= (* default-int 15) 0)
    (= (* default-uint 15) 0)
    (= (* default-long 15) 0)
    (= (* default-ulong 15) 0)
    (= (* default-float 15) 0)
    (= (* default-double 15) 0)))

(define test-multiplication-2 ()
  (and
    (= (* (+ 1 default-int) 15) 15)
    (= (* (+ 1 default-uint) 15) 15)
    (= (* (+ 1 default-long) 15) 15)
    (= (* (+ 1 default-ulong) 15) 15)
    (= (* (+ 1 default-float) 15) 15)
    (= (* (+ 1 default-double) 15) 15)))

; Test alias
(define test-multiplication-3 ()
  (= (mul 1000 111) (* 1000 111)))

(define test-multiplication-4 ()
  (= (* 1000 111) (* 111 1000)))

(define test-multiplication-types ()
  (and
    (= (typestr (* default-int 0)) "int")
    (= (typestr (* default-uint 0)) "uint")
    (= (typestr (* default-long 0)) "long")
    (= (typestr (* default-ulong 0)) "ulong")
    (= (typestr (* default-float 0)) "float")
    (= (typestr (* default-double 0)) "double")))

; SUBSECT Test /

(define test-division ()
  (and
    (= (/ default-int 15) 0)
    (= (/ default-uint 15) 0)
    (= (/ default-long 15) 0)
    (= (/ default-ulong 15) 0)
    (= (/ default-float 15) 0)
    (= (/ default-double 15) 0)))

(define test-division-2 ()
  (and
    (= (/ (+ 10 default-int) 2) 5)
    (= (/ (+ 10 default-uint) 2) 5)
    (= (/ (+ 10 default-long) 2) 5)
    (= (/ (+ 10 default-ulong) 2) 5)
    (= (/ (+ 10 default-float) 2) 5)
    (= (/ (+ 10 default-double) 2) 5)))

; Test alias
(define test-division-3 ()
  (= (div 1000 111) (/ 1000 111)))

(define test-division-types ()
  (and
    (= (typestr (/ default-int 1)) "int")
    (= (typestr (/ default-uint 1)) "uint")
    (= (typestr (/ default-long 1)) "long")
    (= (typestr (/ default-ulong 1)) "ulong")
    (= (typestr (/ default-float 1)) "float")
    (= (typestr (/ default-double 1)) "double")))

; SUBSECT Test %

(define test-modulo()
  (and
    (= (% default-int 15) 0)
    (= (% default-uint 15) 0)
    (= (% default-long 15) 0)
    (= (% default-ulong 15) 0)
    (= (% default-float 15) 0)
    (= (% default-double 15) 0)))

(define test-modulo-2 ()
  (and
    (= (% (+ 10 default-int) 2) 0)
    (= (% (+ 10 default-uint) 2) 0)
    (= (% (+ 10 default-long) 2) 0)
    (= (% (+ 10 default-ulong) 2) 0)
    (= (% (+ 10 default-float) 2) 0)
    (= (% (+ 10 default-double) 2) 0)))

(define test-modulo-3 ()
  (and
    (= (% (+ 10 default-int) 3) 1)
    (= (% (+ 10 default-uint) 3) 1)
    (= (% (+ 10 default-long) 3) 1)
    (= (% (+ 10 default-ulong) 3) 1)
    (= (% (+ 10 default-float) 3) 1)
    (= (% (+ 10 default-double) 3) 1)))

; Test alias
(define test-modulo-4 ()
  (= (mod 1000 111) (% 1000 111)))

(define test-modulo-types ()
  (and
    (= (typestr (/ default-int 1)) "int")
    (= (typestr (/ default-uint 1)) "uint")
    (= (typestr (/ default-long 1)) "long")
    (= (typestr (/ default-ulong 1)) "ulong")
    (= (typestr (/ default-float 1)) "float")
    (= (typestr (/ default-double 1)) "double")))

; SUBSECT Test increment

(define test-inc ()
  (and
    (= (++ default-int) 1)
    (= (++ default-uint) 1)
    (= (++ default-long) 1)
    (= (++ default-ulong) 1)
    (= (++ default-float) 1)
    (= (++ default-double) 1)))

(define test-inc-2 ()
  (and
    (= (++ (++ default-int)) 2)
    (= (++ (++ default-uint)) 2)
    (= (++ (++ default-long)) 2)
    (= (++ (++ default-ulong)) 2)
    (= (++ (++ default-float)) 2)
    (= (++ (++ default-double)) 2)))

; Test alias
(define test-inc-3 ()
  (= (++ 1000) (inc 1000)))

(define test-inc-types ()
  (and
    (= (typestr (+ default-int 0)) "int")
    (= (typestr (+ default-uint 0)) "uint")
    (= (typestr (+ default-long 0)) "long")
    (= (typestr (+ default-ulong 0)) "ulong")
    (= (typestr (+ default-float 0)) "float")
    (= (typestr (+ default-double 0)) "double")))

; SUBSECT Test decrement

(define test-dec ()
  (and
    (= (-- default-int) -1)
    (= (-- default-long) -1)
    (= (-- default-float) -1)
    (= (-- default-double) -1)))

(define test-dec-2 ()
  (and
    (= (-- (++ default-int)) 0)
    (= (-- (++ default-uint)) 0)
    (= (-- (++ default-long)) 0)
    (= (-- (++ default-ulong)) 0)
    (= (-- (++ default-float)) 0)
    (= (-- (++ default-double)) 0)))

; Test alias
(define test-dec-3 ()
  (= (-- 1000) (dec 1000)))

(define test-dec-types ()
  (and
    (= (typestr (-- (++ default-int))) "int")
    (= (typestr (-- (++ default-uint))) "uint")
    (= (typestr (-- (++ default-long))) "long")
    (= (typestr (-- (++ default-ulong))) "ulong")
    (= (typestr (-- (++ default-float))) "float")
    (= (typestr (-- (++ default-double))) "double")))

; SUBSECT Test binary and

(define test-bit-and ()
  (and
    (= (& 3 1) 1)
    (= (& 3 3) 3)
    (= (& 3 0) 0)
    (= (& #t 1) 1)))

(define test-bit-and-2 ()
  (= (bit-and 3 1) (& 3 1)))

; SUBSECT Test binary or

(define test-bit-or ()
  (and
    (= (| 3 1) 3)
    (= (| 3 3) 3)
    (= (| 3 0) 3)
    (= (| #t 1) 1)))

(define test-bit-or-2 ()
  (= (bit-or 3 1) (| 3 1)))

; SUBSECT Test binary xor

(define test-bit-xor ()
  (and
    (= (^ 3 1) 2)
    (= (^ 3 3) 0)
    (= (^ 3 0) 3)
    (= (^ #t 1) 0)))

(define test-bit-xor-2 ()
  (= (bit-xor 33 3) (^ 33 3)))

; SUBSECT Test binary negation

(define test-bit-neg ()
  #t)

; SUBSECT Test bit-shift-left

(define test-bit-shl ()
  (and
    (= (<< 3 1) 6)
    (= (<< 0 3) 0)
    (= (<< 3 0) 3)))

(define test-bit-shl-2 ()
  (= (shl 33 1) (<< 33 1)))

; SUBSECT Test bit-shift-right

(define test-bit-shr ()
  (and
    (= (>> 6 1) 3)
    (= (>> 0 3) 0)
    (= (>> 3 0) 3)))

(define test-bit-shr-2 ()
  (= (shr 33 1) (>> 33 1)))

; SUBSECT Test equality

(define test-equals ()
  (and
    (= 3 3)
    (= 3000 3000)
    (= "abc" "abc")
    (= #t #t)
    (= #f #f)
    (= [] [])
    (= 3.0 3.0)))

(define test-equals-2 ()
   (and
    (not (= 3 3.5))
    (not (= 1 2))
    (not (= "abc" "def"))
    (not (= #t #f))
    (not (= #f #t))
    (not (= 3.0 3.1))))

; SUBSECT Test non-equality

(define test-not-equals ()
  (and
    (not (not= 3 3))
    (not (not= 3000 3000))
    (not (not= "abc" "abc"))
    (not (not= #t #t))
    (not (not= #f #f))
    (not (not= [] []))
    (not (not= 3.0 3.0))))

(define test-not-equals-2 ()
  (and
    (not= 3 3.5)
    (not= 1 2)
    (not= "abc" "def")
    (not= #t #f)
    (not= #f #t)
    (not= 3.0 3.1)))

(define test-not-equals-3 ()
  (and
    (!= 3 3.5)
    (!= 1 2)
    (!= "abc" "def")
    (!= #t #f)
    (!= #f #t)
    (!= 3.0 3.1)))

; SUBSECT Test comparisons

(define test-comparisons ()
  (and
    (< 0 3)
    (> 3 0)
    (<= 0 3)
    (<= 3 3)
    (== 0 0)
    (>= 3 0)
    (>= 3 3)
    (pos? 0)
    (pos? 1)
    (! (pos? -1))
    (neg? -1)
    (! (neg? 0))
    (== (<=> 15 15) 0)
    (== (<=> 15 0) 1)
    (== (<=> 0 15) -1)))

(define test-comparisons-2 ()
  (and
    (< 0.5 3.5)
    (> 3.5 0.5)
    (<= 0.5 3.5)
    (<= 3.5 3.5)
    (== 0.5 0.5)
    (>= 3.5 0.5)
    (>= 3.5 3.5)
    (pos? 0.0)
    (pos? 1.5)
    (! (pos? -1.5))
    (neg? -1.5)
    (! (neg? 0.0))
    (== (<=> 15.5 15.5) 0)
    (== (<=> 15.5 0.5) 1)
    (== (<=> 0.5 15.5) -1)))

(define test-comparisons-3 ()
  (and
    (< "" "a")
    (> "a" "")
    (<= "" "a")
    (<= "" "")
    (== "" "")
    (>= "a" "")
    (>= "a" "a")
    (== (<=> "a" "a") 0)
    (== (<=> "a" "") 1)
    (== (<=> "" "a") -1)))

; SUBSECT Test bool not

(define test-bool-not ()
  (and (! (! #t)) (! #f) (! 0)))

; SUBSECT Test bool and

(define test-bool-and ()
  (and
    (&& #t #t)
    (! (&& #t #f))
    (! (&& #f #t))
    (! (&& #f #f))
    (&& 1 1)
    (! (&& 1 0))
    (! (&& 0 1))
    (! (&& 0 0))
    (&& #t #t #t #t)
    (! (&& #t #f #t #t))
    (! (&& #f #t #t #t))
    (! (&& #f #f #f #f))))

; SUBSECT Test bool nand

(define test-bool-nand ()
  (and
    (! (!&& #t #t))
    (!&& #t #f)
    (!&& #f #t)
    (!&& #f #f)
    (! (!&& 1 1))
    (!&& 1 0)
    (!&& 0 1)
    (!&& 0 0)
    (! (!&& #t #t #t #t))
    (!&& #t #f #t #t)
    (!&& #f #t #t #t)
    (!&& #f #f #f #f)))

; SUBSECT Test bool or

(define test-bool-or ()
  (and
    (|| #t #t)
    (|| #t #f)
    (|| #f #t)
    (! (|| #f #f))
    (|| 1 1)
    (|| 1 0)
    (|| 0 1)
    (! (|| 0 0))
    (|| #t #t #t #t #t)
    (|| #t #t #t #t #f)
    (|| #f #t #t #t #t)
    (! (|| #f #f #f #f))))

; SUBSECT Test bool nor

(define test-bool-nor ()
  (and
    (! (!|| #t #t))
    (! (!|| #t #f))
    (! (!|| #f #t))
    (!|| #f #f)
    (! (!|| 1 1))
    (! (!|| 1 0))
    (! (!|| 0 1))
    (!|| 0 0)
    (! (!|| #t #t #t #t #t))
    (! (!|| #t #t #t #t #f))
    (! (!|| #f #t #t #t #t))
    (!|| #f #f #f #f)))

; SUBSECT Test bool xor

(define test-bool-xor ()
  (and
    (! (xor #t #t))
    (xor #t #f)
    (xor #f #t)
    (! (xor #f #f))
    (! (xor 1 1))
    (xor 1 0)
    (xor 0 1)
    (! (xor 0 0))))

; SECTION Test collection stuff

; SUBSECT Test size

(define test-size ()
  (and
    (= (size []) 0)
    (= (size [1 2 3]) 3)
    (= (size "") 0)
    (= (size "111") 3)))

; SUBSECT Test values function

(define test-values ()
  (let (v [1 2 3] v2 (values v)
        s "123"   s2 (values s))
    (and (= v v2) (= s s2))))

; SUBSECT Test append

(define test-append ()
  (let (v0 [1 2 3] v1 [4 5 6]
        v2 (append v0 v1)
        s0 "123" s1 "456"
        s2 (append s0 s1))
    (and (= v0 [1 2 3]) (= v1 [4 5 6]) (= v2 [1 2 3 4 5 6])
         (= s0 "123") (= s1 "456") (= s2 "123456"))))

(define test-append-1 ()
  (let (v0 [1 2 3] v1 (append v0 4)
        s0 "123" s1 (append s0 \4))
    (and (= v0 [1 2 3]) (= v1 [1 2 3 4]) (= s0 "123") (= s1 "1234"))))

; SUBSECT Test append!

(define test-append! ()
  (let (v0 [1 2 3] v1 (append! v0 4)
        s0 "123" s1 (append! s0 \4))
    (and (= v0 [1 2 3 4]) (= s0 "1234")
         (= v1 [1 2 3 4]) (= s1 "1234"))))

(define test-append-1! ()
  (let (v0 [1 2 3] v1 [4 5 6] v2 (append! v0 v1)
        s0 "123" s1 "456" s2 (append! s0 s1))
    (and (= v2 [1 2 3 4 5 6]) (= v1 [4 5 6])
         (= s2 "123456") (= s1 "456"))))

; SUBSECT Test prepend

(define test-prepend ()
  (let (v0 [1 2 3] v1 (prepend 4 v0)
        s0 "123" s1 (prepend \4 s0))
    (and (= v0 [1 2 3]) (= v1 [4 1 2 3]) (= s0 "123") (= s1 "4123"))))

; SUBSECT Test coll-clone

(define test-coll-clone ()
  (let (v0 [1 2 3] v1 (coll-clone v0)
        s0 "123" s1 (coll-clone s0))
    (and (= v0 [1 2 3]) (= v1 [1 2 3]) (= s0 "123") (= s1 "123"))))

; SUBSECT Test keys

(define test-keys ()
  (let (coll [1 2 3]
        s "123")
    (and (= (keys coll) [0 1 2]) (= (keys s) [0 1 2]))))

; SUBSECT Test assoc

(define test-assoc! ()
  (let (coll [1 3 3] coll1 [1 4 5])
  (and (= (assoc! coll 1 2) [1 2 3]) ; Element is changed
       (= coll [1 2 3]) ; Collection is changed
       (= (assoc! coll1 0 5) coll1)))) ; It is changed in place

(define test-assoc ()
  (let (coll [1 3 3])
    (and (= (assoc coll 1 2) [1 2 3]) ; Value is assigned
         (= coll [1 3 3])))) ; Original is unchanged

; SUBSECT Test slices

(define test-slice ()
  (let (coll [1 2 3 4 5 6]
        text "123456")
    (and (= coll (slice coll 0))
         (= (slice coll 2) (slice coll 2))
         (= (size (slice coll 1)) 5)
         (= text (slice text 0))
         (= (slice text 2) (slice text 2))
         (= (size (slice text 1)) 5))))

(define test-slice-1 ()
  (let (coll [1 2 3 4 5 6] text "123456")
    (and (= coll (slice coll 0 0))
         (= (slice coll 2 0) [3 4 5 6])
         (= (slice coll 2 1) [3 4 5])
         (= (slice coll 2 1) (slice coll 2 1))
         (= (size (slice coll 1 1)) 4)
         (= text (slice text 0 0))
         (= (slice text 2 2) (slice text 2 2))
         (= (size (slice text 1 1)) 4))))

; SUBSECT Test get

(define test-get ()
  (let (coll [1 2 3 4]
        text "1234")
    (and (= (get coll 0) 1)
         (= (get coll 1) 2)
         (= (get coll 2) 3)
         (= (get text 0) \1)
         (= (get text 1) \2)
         (= (get text 2) \3))))

; SUBSECT Test cleared

(meta (:visibility :private :returns ::bool)
; Return #t if called with an int-array as its argument.
; There is no overload for other types, so it is always #t.
  (define is-int-array? (::int[] a) #t)
)

(define test-cleared ()
  (let (coll [1 2 3 4 5])
    (and (= (cleared coll) [])
        (is-int-array? (cleared coll))
        (= (append (cleared coll) coll) coll))))

; SUBSECT Test resized

(define test-resized ()
  (let (coll [1 1 1])
    (and (= (resized coll 0) [])
         (= (resized coll 1) [1])
         (= (resized coll 4) [1 1 1 0])
         (= (resized (resized coll 0) 5) [0 0 0 0 0])
         (is-int-array? (resized coll 8)))))

; SUBSECT Test vector

(define test-vector ()
  (and (= (vector 1 2 3 4) [1 2 3 4])
       (is-int-array? (vector 1 2 3))
       (= (size (vector 0 1 2 3 4 5 6 7 8 9 10 11 12)) 13)))

; SUBSECT Test first/second/third

(define test-first ()
  (let (coll [1 2 3 4])
    (and (= (first coll) 1)
         (= (first coll) (get coll 0)))))

(define test-second ()
  (let (coll [1 2 3 4])
    (and (= (second coll) 2)
         (= (second coll) (get coll 1)))))

(define test-last ()
  (let (coll [1 2 3 4])
    (= (last coll) 4)))

; SUBSECT Test rest

(define test-rest ()
  (and (= (rest [1 2 3]) [2 3])
       (= (rest [1]) [])))

; SUBSECT Test empty?

(define test-empty ()
  (and (empty? [])
       (not (empty? [1]))
       (empty? "")))

(define test-not-empty ()
  (and (not-empty? [1])
       (not (not-empty? []))
       (not-empty? "1")))

; SUBSECT Test key-of and index-of

(define test-key-of ()
  (let (coll [15 16 17])
    (and (= (key-of coll 16) 1)
         (= (key-of coll 61) 0)
         (= (key-of coll 16 7) 1)
         (= (key-of coll 61 7) 7))))

(define test-key-of1 ()
  (let (coll "678")
    (and (= (key-of coll \6) 0)
         (= (key-of coll \6 7) 0)
         (= (key-of coll \9 7) 7))))

(define test-index-of ()
  (let (coll [15 16 17])
    (and (= (index-of coll 16) 1)
         (= (index-of coll 61) -1)
         (= (index-of coll 16) 1)
         (= (index-of coll 61) -1))))

(define test-index-of1 ()
  (let (coll "678")
    (and (= (index-of coll \6) 0)
         (= (index-of coll \9) -1)
         (= (index-of coll \6) 0)
         (= (index-of coll \9) -1))))

; SECTION Test starts-with? / ends-with?

(define test-starts-with ()
  (let (coll [1 2 3 4])
    (and (starts-with? coll 1)
         (starts-with? (rest coll) 2)
         (starts-with? coll [1 2])
         (not (starts-with? coll 2))
         (not (starts-with? coll [1 2 3 4 5]))
         (starts-with? coll coll))))

(define test-ends-with ()
  (let (coll [1 2 3 4])
    (and (ends-with? coll 4)
         (ends-with? (slice coll 0 1) 3)
         (ends-with? coll coll)
         (ends-with? coll [3 4]))))

; SECTION Test functional fundamentals

(define test-reduce ()
  (let (coll [1 2 3 4 5 6])
    (= (reduce (lambda (::int i ::int j) (+ i j)) coll 0) 21)))

(define test-reduce-1 ()
  (let (coll [1 2 3 4 5 6])
    (= (reduce (lambda ::int (::int i ::int j) (+ i j)) coll) 21)))

(define test-reduce-2 ()
  (let (coll [1 2 3 4 5 6])
    (= (reduce (lambda (::int i ::int j) (- j i)) coll) -19)))

(define ::int test-reduce-3-sub (::int i ::int j) (- j i))
(define test-reduce-3 ()
  (let (coll [1 2 3 4 5 6])
    (= (reduce (fp test-reduce-3-sub) coll) -19)))

(define test-reduce-4 ()
  (let (::int[] coll [1 2 3 4 5 6])
    (= (reduce 
         (lambda ::string (::int i ::string s) (append s (to_s i)))
         coll "")
       "123456")))

(define test-reduce-5 ()
  (let (coll [1 2 3 4 5 6])
    (=
      (reduce (lambda ::int[][] (::int i ::int[][] res) (append res [i])) coll [])
      [[1] [2] [3] [4] [5] [6]])))

; SECTION Test filter and reduce

(define ::bool test-filter-odd-helper (::int i)
  (== 1 (% i 2)))

(define test-filter ()
  (let (coll [1 2 3 4 5 6])
    (and (= (filter (lambda ::bool (::int i) (!= 0 (& i 1))) coll) [1 3 5])
         (= (filter (lambda ::bool (::int i) (< i 4)) coll) [1 2 3])
         (= (filter (fp test-filter-odd-helper) coll) [1 3 5]))))

(define test-remove ()
  (let (coll [1 2 3 4 5 6])
    (and (= (remove (lambda ::bool (::int i) (!= 0 (& i 1))) coll) [2 4 6])
         (= (remove (lambda ::bool (::int i) (< i 4)) coll) [4 5 6])
         (= (remove (fp test-filter-odd-helper) coll) [2 4 6]))))

; SECTION Test any / all / none

(define test-any? ()
  (let (coll [1 2 3 4 5 6])
    (and (any? (lambda ::bool (::int i) (> i 3)) coll) ; Partially true
         (any? (lambda ::bool (::int i) (> i 0)) coll) ; All true
         (! (any? (lambda ::bool (::int i) (> i 6)) coll)) ; None true -> #f
         (! (any? (lambda ::bool (::int i) (> i 0)) []))))) ; Empty -> #f

(define test-all? ()
  (let (coll [1 2 3 4 5 6])
    (and (! (all? (lambda ::bool (::int i) (> i 3)) coll)) ; Partially true -> #f
         (all? (lambda ::bool (::int i) (> i 0)) coll) ; All true
         (! (all? (lambda ::bool (::int i) (> i 6)) coll)) ; None true -> #f
         (all? (lambda ::bool (::int i) (> i 0)) [])))) ; Empty -> #t

(define test-none? ()
  (let (coll [1 2 3 4 5 6])
    (and (! (none? (lambda ::bool (::int i) (> i 3)) coll)) ; Partially true -> #f
         (! (none? (lambda ::bool (::int i) (> i 0)) coll)) ; All true -> #f
         (none? (lambda ::bool (::int i) (> i 6)) coll) ; None true
         (none? (lambda ::bool (::int i) (> i 0)) [])))) ; Empty

; SECTION Test includes? / in? / contains?

(define test-includes? ()
  (let (coll [1 2 3 4 5 6])
    (and
      (all? (lambda ::bool (::int i) (includes? coll i)) [1 2 3 4 5 6])
      (none? (lambda ::bool (::int i) (includes? coll i)) [-1 0 7 10]))))

(define test-includes-1? ()
  (let (::int[] coll [])
    (none? (lambda ::bool (::int i) (includes? coll i)) [-1 0 1 2 3 4 5 6 7 10])))

(define test-includes-2? ()
  (let (coll [1 2 3 4 5 6])
    (and
      (all? (lambda ::bool (::int[] i) (includes? coll i)) [[1] [] coll (rest coll)])
      (none? (lambda ::bool (::int[] i) (includes? coll i)) [[0] (append coll 1)]))))

(define test-in? ()
  (let (coll [1 2 3 4 5 6])
    (and
      (all? (lambda ::bool (::int i) (in? coll i)) [1 2 3 4 5 6])
      (none? (lambda ::bool (::int i) (in? coll i)) [-1 0 7 10]))))

(define test-in-1? ()
  (let (::int[] coll [])
    (none? (lambda ::bool (::int i) (in? coll i)) [-1 0 1 2 3 4 5 6 7 10])))

(define test-in-2? ()
  (let (coll [1 2 3 4 5 6])
    (and 
      (all? (lambda ::bool (::int[] i) (in? coll i)) [[1] [] coll (rest coll)])
      (none? (lambda ::bool (::int[] i) (in? coll i)) [[0] (append coll 1)]))))

(define test-contains? ()
  (let (coll [1 2 3 4 5 6])
    (and
      (all? (lambda ::bool (::int i) (contains? coll i)) [1 2 3 4 5 6])
      (none? (lambda ::bool (::int i) (contains? coll i)) [-1 0 7 10]))))

(define test-contains-1? ()
  (let (::int[] coll [])
    (none? (lambda ::bool (::int i) (contains? coll i)) [-1 0 1 2 3 4 5 6 7 10])))

(define test-contains-2? ()
  (let (coll [1 2 3 4 5 6])
    (and
      (all? (lambda ::bool (::int[] i) (contains? coll i)) [[1] [] coll (rest coll)])
      (none? (lambda ::bool (::int[] i) (contains? coll i)) [[0] (append coll 1)]))))

; SECTION Test map

(define test-map ()
  (let (coll [1 2 3 4 5 6])
    (= (map (lambda ::int (::int i) (++ i)) coll) [2 3 4 5 6 7])))

(define test-map-into ()
  (let (coll [1 2 3 4 5 6] ::int[] dest [])
    (= (map-into (lambda ::int (::int i) (++ i)) coll dest) [2 3 4 5 6 7])))

(define test-map-into-1 ()
  (let (coll [1 2 3 4 5 6] dest [1 2 3])
    (= (map-into (lambda ::int (::int i) (++ i)) coll dest) [1 2 3 2 3 4 5 6 7])))

(define test-map! ()
  (let (coll [1 2 3 4 5 6])
    (and 
      (= (map! (lambda ::int (::int i) (++ i)) coll) [2 3 4 5 6 7])
      (= coll [2 3 4 5 6 7]))))

; SECTION Test join

(define test-join ()
  (let (::int[] empty_int_arr [])
    (and
      (= (join empty_int_arr) "")
      (= (join [1 2 3]) "123")
      (= (join [123]) "123"))))

; SECTION Test uniq / distinct

(define test-uniq ()
  (let (::int[] empty_int_arr [])
    (and
      (= (uniq empty_int_arr) empty_int_arr)
      (= (uniq [1 1 1]) [1])
      (= (uniq [1 2 3 1 2 3]) [1 2 3])
      (= (uniq [1 2 3 2 1 0]) [1 2 3 0]))))

(define test-distinct ()
  (let (::int[] empty_int_arr [])
    (and
      (= (distinct empty_int_arr) empty_int_arr)
      (= (distinct [1 1 1]) [1])
      (= (distinct [1 2 3 1 2 3]) [1 2 3])
      (= (distinct [1 2 3 2 1 0]) [1 2 3 0]))))

; SECTION Test uniq? / is-unique? / is-distinct?

(define test-uniq? ()
  (let (::int[] empty_int_arr [])
    (and
      (uniq? empty_int_arr)
      (uniq? [1 2 3 4])
      (uniq? [1])
      (! (uniq? [1 2 3 2])))))

(define test-is-distinct? ()
  (let (::int[] empty_int_arr [])
    (and
      (is-distinct? empty_int_arr)
      (is-distinct? [1 2 3 4])
      (is-distinct? [1])
      (! (is-distinct? [1 2 3 2])))))

(define test-is-unique? ()
  (let (::int[] empty_int_arr [])
    (and
      (is-unique? empty_int_arr)
      (is-unique? [1 2 3 4])
      (is-unique? [1])
      (! (is-unique? [1 2 3 2])))))

; SECTION Test sort

(define test-sort ()
  (let (::int[] coll [])
    (and
      (= (sort coll) [])
      (= (sort coll) (sort coll)))))

(define test-sort-1 ()
  (let (coll        [1 2 3 4 5 6]
        coll-sorted [1 2 3 4 5 6])
    (and
      (= (sort coll) coll-sorted)
      (= (sort coll) (sort coll)))))

(define test-sort-2 ()
  (let (coll        [6 5 4 3 2 1]
        coll-sorted [1 2 3 4 5 6])
    (and
      (= (sort coll) coll-sorted)
      (= (sort coll) (sort coll)))))

(define test-sort-3 ()
  (let (coll        [3 4 6 3 2 1 8 9 10]
        coll-sorted [1 2 3 3 4 6 8 9 10])
    (and
      (= (sort coll) coll-sorted)
      (= (sort coll) (sort coll)))))

; SECTION Test sum

(define test-sum ()
  (let (::int[] empty-coll [])
    (and
      (= (sum [1 2 3]) 6)
      (= (sum empty-coll) 0)
      (= (sum [0 0 0]) 0)
      (= (sum [-1 -1 -1 -1]) -4))))

; SECTION Test min / max

(define test-min ()
  (let (::int[] empty-coll [])
    (and
      (= (min empty-coll) default-int)
      (= (min [1]) 1)
      (= (min [1 2 3 4 5 6]) 1)
      (= (min [6 5 4 3 2 1]) 1))))

(define test-max ()
  (let (::int[] empty-coll [])
    (and
      (= (max empty-coll) default-int)
      (= (max [1]) 1)
      (= (max [1 2 3 4 5 6]) 6)
      (= (max [6 5 4 3 2 1]) 6))))

; SECTION Test limit

(define test-limit ()
  (and
    (= (limit 0 0) 0)
    (= (limit 0 1) 0)
    (= (limit -1 0) -1)
    (= (limit 500 5) 5)
    (= (limit 500 1000) 500)))

(define test-limit-1 ()
  (and
    (= (limit 0 0 0) 0)
    (= (limit 0 0 1) 0)
    (= (limit -1 -1 0) -1)
    (= (limit 500 0 5) 5)
    (= (limit 500 0 1000) 500)
    (= (limit 500 501 1000) 501)
    (= (limit 500 -1000 1000) 500)))

; SECTION Test divisors and sum-of-divisors

(define test-divisors ()
  (and
    (= (divisors 12) [6 4 3 2 1])
    (= (divisors 0) (cleared [0L]))))

(define test-sum-of-divisors ()
  (and
    (= (sum-of-divisors 0) 0)
    (= (sum-of-divisors 12) 16)))

; SECTION Test random

(define test-rseed ()
  (let (rand (rseed 0)
        rand2 (rseed 1001))
    (and (= rand.seed 0)
         (= rand2.seed 1001))))

(define test-random ()
  (and
    (!= (long-value (random 0)) 0)
    (== (long-value (random 1))
        (long-value (random (rseed 1))))
    (== (long-value (random default-seed))
        (long-value (random default-seed)))))

(define test-random-1 ()
  (let (rand (rseed default-seed))
    (and
      (== (ulong-value (random rand 0)) 0)
      (<= (ulong-value (random rand 1)) 1))))

(define test-random-2 ()
  (let (rand (rseed default-seed))
    (and
      (== (ulong-value (random rand 0 0)) 0)
      (<= (ulong-value (random rand 0 1)) 1))))

(define test-random-3 ()
  (loop (rand (random (rseed 2048) 100)
         counter 1000)
    (when (= counter 0) #t
    (when (> (ulong-value rand) 100) #f
    (recur (random rand 100) (-- counter))))))

(define test-random-4 ()
  (loop (rand (random (rseed 2048) 50 100)
         counter 1000)
    (when (= counter 0) #t
    (when (> (ulong-value rand) 100) #f
    (when (< (ulong-value rand) 50) #f
    (recur (random rand 50 100) (-- counter)))))))






) ; Ends meta (returns bool)


; SECTION Run tests

(define ::void main1 ()
    (println! (append "test-defaults      " (to_s (test-defaults))))
    (println! (append "test-default-types " (to_s (test-default-types))))
    (println! "")
    (println! (append "test-add           " (to_s (test-addition))))
    (println! (append "test-add-2         " (to_s (test-addition-2))))
    (println! (append "test-add-3         " (to_s (test-addition-3))))
    (println! (append "test-add-4         " (to_s (test-addition-4))))
    (println! (append "test-add-types     " (to_s (test-addition-types))))
    (println! (append "test-sub           " (to_s (test-subtraction))))
    (println! (append "test-sub-2         " (to_s (test-subtraction-2))))
    (println! (append "test-sub-3         " (to_s (test-subtraction-3))))
    (println! (append "test-sub-types     " (to_s (test-subtraction-types))))
    (println! (append "test-mul           " (to_s (test-multiplication))))
    (println! (append "test-mul-2         " (to_s (test-multiplication-2))))
    (println! (append "test-mul-3         " (to_s (test-multiplication-3))))
    (println! (append "test-mul-4         " (to_s (test-multiplication-4))))
    (println! (append "test-mul-types     " (to_s (test-multiplication-types))))
    (println! (append "test-div           " (to_s (test-division))))
    (println! (append "test-div-2         " (to_s (test-division-2))))
    (println! (append "test-div-3         " (to_s (test-division-3))))
    (println! (append "test-div-types     " (to_s (test-division-types))))
    (println! (append "test-mod           " (to_s (test-modulo))))
    (println! (append "test-mod-2         " (to_s (test-modulo-2))))
    (println! (append "test-mod-3         " (to_s (test-modulo-3))))
    (println! (append "test-mod-4         " (to_s (test-modulo-4))))
    (println! (append "test-mod-types     " (to_s (test-modulo-types))))
    (println! "")
    (println! (append "test-inc           " (to_s (test-inc))))
    (println! (append "test-inc-2         " (to_s (test-inc-2))))
    (println! (append "test-inc-3         " (to_s (test-inc-3))))
    (println! (append "test-inc-types     " (to_s (test-inc-types))))
    (println! (append "test-dec           " (to_s (test-dec))))
    (println! (append "test-dec-2         " (to_s (test-dec-2))))
    (println! (append "test-dec-3         " (to_s (test-dec-3))))
    (println! (append "test-dec-types     " (to_s (test-dec-types))))
    (println! "")
    (println! (append "test-bit-and       " (to_s (test-bit-and))))
    (println! (append "test-bit-and-2     " (to_s (test-bit-and-2))))
    (println! (append "test-bit-or        " (to_s (test-bit-or))))
    (println! (append "test-bit-and-2     " (to_s (test-bit-and-2))))
    (println! (append "test-bit-xor       " (to_s (test-bit-xor))))
    (println! (append "test-bit-xor-2     " (to_s (test-bit-xor-2))))
    (println! "")
    (println! (append "test-bit-neg       " (to_s (test-bit-neg))))
    (println! (append "test-bit-shl       " (to_s (test-bit-shl))))
    (println! (append "test-bit-shl-2     " (to_s (test-bit-shl-2))))
    (println! (append "test-bit-shr       " (to_s (test-bit-shr))))
    (println! (append "test-bit-shr-2     " (to_s (test-bit-shr-2))))
    (println! "")
    (println! (append "test-equals        " (to_s (test-equals))))
    (println! (append "test-equals-2      " (to_s (test-equals-2))))
    (println! (append "test-not-equals    " (to_s (test-not-equals))))
    (println! (append "test-not-equals-2  " (to_s (test-not-equals-2))))
    (println! "")
    (println! (append "test-comparisons   " (to_s (test-comparisons))))
    (println! (append "test-comparisons-2 " (to_s (test-comparisons-2))))
    (println! (append "test-comparisons-3 " (to_s (test-comparisons-3))))
    (println! "")
    (println! (append "test-bool-not      " (to_s (test-bool-not))))
    (println! (append "test-bool-and      " (to_s (test-bool-and))))
    (println! (append "test-bool-nand     " (to_s (test-bool-nand))))
    (println! (append "test-bool-or       " (to_s (test-bool-or))))
    (println! (append "test-bool-nor      " (to_s (test-bool-nor))))
    (println! (append "test-bool-xor      " (to_s (test-bool-xor))))
    (println! "")
    (println! (append "test-size          " (to_s (test-size))))
    (println! (append "test-values        " (to_s (test-values))))
    (println! (append "test-append        " (to_s (test-append))))
    (println! (append "test-append-1      " (to_s (test-append-1))))
    (println! (append "test-append-!      " (to_s (test-append!))))
    (println! (append "test-append-!-1    " (to_s (test-append-1!))))
    (println! (append "test-prepend       " (to_s (test-prepend))))
    (println! (append "test-coll-clone    " (to_s (test-coll-clone))))
    (println! "")
    (println! (append "test-keys          " (to_s (test-keys))))
    (println! (append "test-assoc!        " (to_s (test-assoc!))))
    (println! (append "test-assoc         " (to_s (test-assoc))))
    (println! (append "test-slice         " (to_s (test-slice))))
    (println! (append "test-slice-1       " (to_s (test-slice-1))))
    (println! (append "test-get           " (to_s (test-get))))
    (println! (append "test-cleared       " (to_s (test-cleared))))
    (println! (append "test-resized       " (to_s (test-resized))))
    (println! (append "test-vector        " (to_s (test-vector))))
    (println! "")
    (println! (append "test-first         " (to_s (test-first))))
    (println! (append "test-second        " (to_s (test-second))))
    (println! (append "test-last          " (to_s (test-last))))
    (println! (append "test-rest          " (to_s (test-rest))))
    (println! (append "test-empty         " (to_s (test-empty))))
    (println! (append "test-not-empty     " (to_s (test-not-empty))))
    (println! (append "test-key-of        " (to_s (test-key-of))))
    (println! (append "test-key-of1       " (to_s (test-key-of1))))
    (println! (append "test-index-of      " (to_s (test-index-of))))
    (println! (append "test-index-of1     " (to_s (test-index-of1))))
    (println! "")
    (println! (append "test-starts-with   " (to_s (test-starts-with))))
    (println! (append "test-ends-with     " (to_s (test-ends-with))))
    (println! (append "test-reduce        " (to_s (test-reduce))))
    (println! (append "test-reduce-1      " (to_s (test-reduce-1))))
    (println! (append "test-reduce-2      " (to_s (test-reduce-2))))
    (println! (append "test-reduce-3      " (to_s (test-reduce-3))))
    (println! (append "test-reduce-4      " (to_s (test-reduce-4))))
    (println! (append "test-reduce-5      " (to_s (test-reduce-5))))
    (println! "")
    (println! (append "test-filter        " (to_s (test-filter))))
    (println! (append "test-remove        " (to_s (test-remove))))
    (println! (append "test-any           " (to_s (test-any?))))
    (println! (append "test-all           " (to_s (test-all?))))
    (println! (append "test-none          " (to_s (test-none?))))
    (println! "")
    (println! (append "test-includes?     " (to_s (test-includes?))))
    (println! (append "test-includes-1?   " (to_s (test-includes-1?))))
    (println! (append "test-includes-2?   " (to_s (test-includes-2?))))
    (println! (append "test-in?           " (to_s (test-includes?))))
    (println! (append "test-in-1?         " (to_s (test-includes-1?))))
    (println! (append "test-in-2?         " (to_s (test-includes-2?))))
    (println! (append "test-contains?     " (to_s (test-includes?))))
    (println! (append "test-contains-1?   " (to_s (test-includes-1?))))
    (println! (append "test-contains-2?   " (to_s (test-includes-2?))))
    (println! "")
    (println! (append "test-map           " (to_s (test-map))))
    (println! (append "test-map-into      " (to_s (test-map-into))))
    (println! (append "test-map-into-1    " (to_s (test-map-into-1))))
    (println! (append "test-map!          " (to_s (test-map!))))
    (println! "")
    (println! (append "test-join          " (to_s (test-join))))
    (println! "")
    (println! (append "test-uniq          " (to_s (test-uniq))))
    (println! (append "test-distinct      " (to_s (test-distinct))))
    (println! (append "test-uniq?         " (to_s (test-uniq?))))
    (println! (append "test-is-distinct?  " (to_s (test-is-distinct?))))
    (println! (append "test-is-unique?    " (to_s (test-is-unique?))))
    (println! "")
    (println! (append "test-sort          " (to_s (test-sort))))
    (println! (append "test-sort-1        " (to_s (test-sort-1))))
    (println! (append "test-sort-2        " (to_s (test-sort-2))))
    (println! (append "test-sort-3        " (to_s (test-sort-3))))
    (println! "")
    (println! (append "test-sum           " (to_s (test-sum))))
    (println! (append "test-min           " (to_s (test-min))))
    (println! (append "test-max           " (to_s (test-max))))
    (println! (append "test-divisors      " (to_s (test-divisors))))
    (println!         "test-sum-of-divisors")
    (println! (append "                   " (to_s (test-sum-of-divisors))))
    (println! "")
    (println! (append "test-limit         " (to_s (test-limit))))
    (println! (append "test-limit-1       " (to_s (test-limit-1))))
    (println! "")
    (println! (append "test-rseed         " (to_s (test-rseed))))
    (println! (append "test-random        " (to_s (test-random))))
    (println! (append "test-random-1      " (to_s (test-random-1))))
    (println! (append "test-random-2      " (to_s (test-random-2))))
    (println! (append "test-random-3      " (to_s (test-random-3))))
    (println! (append "test-random-4      " (to_s (test-random-4))))
)

