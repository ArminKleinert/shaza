(module compiler)

(import-sz sz/stdlib)

(def-struct Token
  ::string text
  ::Keyword type
  ::size_t line
  ::size_t index)

(def-struct Node
  ::string text
  ::Keyword type
  ::size_t line
  ::size_t index
  ::Node[] children)

(comment TokenTypes:
    :unknown
    :root
    :lit-int
    :lit-uint
    :lit-flt
    :lit-bool
    :lit-string
    :lit-char
    :lit-list
    :lit-map
    :lit-keyword
    :lit-type
    :symbol
    :buildin-fn-call
    :buildin-macro-call
    :scope-open
    :scope-close
    :lst-open
    :lst-tagged-open
    :lst-close
    :closed-scope
    :closed-tagged-list
    :closed-list
    :ln-comment
)

(define ::Token[] tokens [])
(define ::size_t line 0)
(define ::size_t chIndex 0)
(define ::size_t start-line 0)
(define ::size_t start-char 0)
(define ::bool next-escaped #f)
(define ::string curr-text "")
(define ::bool is-in-string #f)
(define ::bool is-in-type-literal #f)

(define ::char quot-mark (ch "\""))

(meta (:returns ::bool)
(define is-string-literal? (::string text)
  (and (>= (size text) 2)
       (= (first text) quot-mark)
       (= (last text) quot-mark)))

(define is-valid-symbol? (::string text)
  (if (< (size text) 2)
    (return false))
  (loop (curr (first text) ::string rst "")
    (if (empty? rst)
      (return true))
    (if (in? "\";()[]{}#:" curr)
      (return false)
      (recur (first rst) (slice rst 1)))))

(define is-valid-integral? (::string text)
  (to-long-valid? text))

(define is-valid-unsigned? (::string text)
  (to-ulong-valid? text))

(define is-valid-float? (::string text)
  (to-double-valid? text))

(define is-valid-number? (::string text)
  (and (is-valid-integral? text) (is-valid-float? text)))

(define is-type-literal? (::string text)
  (starts-with? text "::"))

(define is-keyword-literal? (::string text)
  (and (>= (size text) 2) (= (first text) \:) (is-valid-symbol? (rest text))))

(define is-bool-literal? (::string text)
  (in? ["#t" "#f"] text))

(define is-char-literal? (::string text)
  (and (not-empty? text)
    (or (in? ["\\space" "\\newline" "\\tab"] text)
        (and (= (first text) (first "\\")) (= (size text) 2)))))

(define is-type-literal? (::string text)
    (let (idx-of-ob  (index-of text (first "("))
          idx-of-cb  (index-of text (first ")"))
          idx-of-ocb (index-of text (first "{"))
          idx-of-ccb (index-of text (first "}"))
          idx-of-osb (index-of text (first "["))
          idx-of-csb (index-of text (first "]"))
          last-txt-idx (dec (size text))

          res0 (&& (pos? idx-of-ob) (> idx-of-ob idx-of-cb)) ; Handle () in symbol
          res1 (|| res0 (&& (pos? idx-of-ocb) (> idx-of-ocb idx-of-ccb))) ; Handle {} in symbol
          res2 (|| res1 (&& (pos? idx-of-osb) (> idx-of-osb idx-of-csb))) ; Handle [] in symbol
          )
      (return (not res2))))

(define last-char-must-be-separated (::string text)
  (||
    (&& (== (last text) (ch ")")) (not (contains? text (ch "("))))
    (&& (== (last text) (ch "]")) (not (contains? text (ch "["))))
    (&& (== (last text) (ch "}")) (not (contains? text (ch "{"))))
    (== (last text) (ch ";"))))
)






