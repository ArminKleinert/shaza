(module shaza-compiler)

(import-sz sz/stdlib)

(def-type Token
  ::string text
  ::Keyword type
  ::size_t line
  ::size_t index)

(def-type Node
  ::string text
  ::Keyword type
  ::size_t line
  ::size_t index
  ::Node[] children)

(def-type Context
  ::Token[] tokens
  ::Node ast
  ::int curr-tkn-line
  ::int curr-tkn-char
  ::int curr-tkn-start-line
  ::int curr-tkn-start-char
  ::bool next-escaped
  ::string curr-tkn-text
  ::bool is-in-string
  ::bool is-in-type-literal)

(comment TokenTypes:
    :unknown
    :root
    :lit-int
    :lit-uint
    :lit-flt
    :lit-bool
    :lit-string
    :lit-char
    :lit-list
    :lit-map
    :lit-keyword
    :lit-type
    :symbol
    :buildin-fn-call
    :buildin-macro-call
    :scope-open
    :scope-close
    :lst-open
    :lst-tagged-open
    :lst-close
    :closed-scope
    :closed-tagged-list
    :closed-list
    :ln-comment
)

(define ::char quot-mark (first "\""))

(meta (:returns ::bool)
(define is-string-literal? (::string text)
  (and (>= (size text) 2)
       (= (first text) quot-mark)
       (= (last text) quot-mark)))

(define is-valid-symbol? (::string text)
  (when (< (size text) 2)
    (return false))
  (loop (::char curr (first text) ::string rst "")
    (when (empty? rst) #t
    (when (in? "\";()[]{}#:" curr)
      #f (recur (first rst) (slice rst 1))))))

(define is-valid-integral? (::string text)
  (to-long-valid? text))

(define is-valid-unsigned? (::string text)
  (to-ulong-valid? text))

(define is-valid-float? (::string text)
  (to-double-valid? text))

(define is-valid-number? (::string text)
  (and (is-valid-integral? text) (is-valid-float? text)))

(define is-keyword-literal? (::string text)
  (and (>= (size text) 2) (= (first text) \:) (is-valid-symbol? (rest text))))

(define is-bool-literal? (::string text)
  (in? ["#t" "#f"] text))

(define is-char-literal? (::string text)
  (and (not-empty? text)
    (or (in? ["\\space" "\\newline" "\\tab"] text)
        (and (= (first text) (first "\\_")) (= (size text) 2)))))

; FIXME
(define is-type-literal? (::string text)
  (when (! (starts_with? text "::")) (return #f))
  (let (idx-of-ob  (index-of text (first "("))
        idx-of-cb  (index-of text (first ")"))
        idx-of-ocb (index-of text (first "{"))
        idx-of-ccb (index-of text (first "}"))
        idx-of-osb (index-of text (first "["))
        idx-of-csb (index-of text (first "]"))
        last-txt-idx (dec (size text))

        res0 (&& (pos? idx-of-ob) (> idx-of-ob idx-of-cb)) ; Handle () in symbol
        res1 (|| res0 (&& (pos? idx-of-ocb) (> idx-of-ocb idx-of-ccb))) ; Handle {} in symbol
        res2 (|| res1 (&& (pos? idx-of-osb) (> idx-of-osb idx-of-csb))) ; Handle [] in symbol
        )
    (return (not res2))))

; FIXME
(define last-char-must-be-separated (::string text)
  (||
    (&& (== (last text) (first ")")) (not (contains? text (first "("))))
    (&& (== (last text) (first "]")) (not (contains? text (first "["))))
    (&& (== (last text) (first "}")) (not (contains? text (first "{"))))
    (== (last text) (first ";"))))

(define is-tagged-list-opener? (::string text)
  (or (= text "Set[") (or (= text "Map[") (= text "Lst["))))
)

(define ::Keyword tkn-type-by-text (::string text)
  (if (is-valid-integral? text) :lit-int
  (if (is-valid-unsigned? text) :lit-uint
  (if (is-valid-float? text) :lit-flt
  (if (is-bool-literal? text) :lit-bool
  (if (is-keyword-literal? text) :lit-keyword
  (if (is-type-literal? text) :lit-type
  (if (is-valid-symbol? text) :symbol
  (if (is-string-literal? text) :lit-string
  (if (is-tagged-list-opener? text) :lst-tagged-open
  (if (= text "[") :lst-open
  (if (= text "]") :lst-close
  (if (= text "(") :scope-open
  (if (= text ")") :scope-close
  (if (= text ";") :ln-comment
  :unknown)))))))))))))))

; TODO
(define ::Token[] create-tokens (::Context ctx ::string s)
  [])

(define ::Context add-tokens (::Context ctx ::Token[] tkns)
  (new ::Context
    (append ctx.tokens tkns) ctx.ast
    ctx.curr-tkn-line ctx.curr-tkn-char
    ctx.curr-tkn-line ctx.curr-tkn-char
    #f "" #f #f))

(define ::Context close-token (::Context ctx ::string c)
  (add-tokens ctx (create-tokens ctx (append ctx.curr-tkn-text c))))

(define ::Context close-token (::Context ctx)
  (add-tokens ctx (create-tokens ctx ctx.curr-tkn-text)))

; TODO
(define ::Context tokenize-sub-next-char-in-string (::Context ctx ::string c)
  ctx)

(define ::Context tokenize-sub-next-char (::Context ctx ::string c)
  (when (= c "\"")
    (let ()
      (when (! ctx.is-in-type-literal)
        (setv! ctx (close-token ctx)))
      (setv! ctx.is-in-string #t)
      (setv! ctx.curr-tkn-text (append ctx.curr-tkn-text c))
      ctx)
  (when (and (= c ":") (= ctx.curr-tkn-text ":"))
    (let ()
      (setv! ctx.is-in-type-literal #t)
      (setv! ctx.curr-tkn-text (append ctx.curr-tkn-text c))
      ctx)
  (when (or (or (= c " ") (= c "\t")) (= c "\n"))
    (close-token ctx c)
  (when (or
          (and (= c "]") (! (includes? ctx.curr-tkn-text "[")))
          (and (= c ")") (! (includes? ctx.curr-tkn-text "(")))
          (and (= c "}") (! (includes? ctx.curr-tkn-text "{"))))
    (close-token ctx c)
  (when (and (! ctx.is-in-type-literal)
             (or (= c "(") (= c ")") (= c "]")))
    ctx
    ctx
    ))))))

(define ::Context next-char (::Context ctx ::char c)
  (setv! ctx curr-tkn-char (inc ctx.curr_tkn_char))
  (when (= c \newline)
    (setv! ctx curr-tkn-line (inc ctx.curr_tkn_line))
    (setv! ctx curr-tkn-char (inc ctx.curr_tkn_char)))
  (when ctx.is_in_string
    (tokenize-sub-next-char-in-string ctx (append "" c))
    (tokenize-sub-next-char ctx (append "" c))))

(comment
(define ::Context tokenize (::Context ctx ::string source)
  (close-token
    (reduce
      (lambda ::Context (::char c ::Context ctx1) (next-char ctx1 c))
      source ctx)))
)










