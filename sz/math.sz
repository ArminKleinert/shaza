(module math)

(import-sz sz/stdlib)

(meta (:generics [::T])
(define ::T sum (::T[] seq)
  (reduce
    (lambda ::T (::T l0 ::T l1) (+ l0 l1))
    seq 0))

(define ::T min (::T[] coll)
  (when (= (size coll) 0) (llr "T.init")
  (when (= (size coll) 1) (first coll)
  (loop (::T[] c (rest coll)
         ::T res (first coll))
    (when (empty? c) res
    (when (< (first c) res)
      (recur (rest c) (first c))
      (recur (rest c) res)))))))

(define ::T max (::T[] coll)
  (when (= (size coll) 0) (llr "T.init")
  (when (= (size coll) 1) (first coll)
  (loop (::T[] c (rest coll)
         ::T res (first coll))
    (when (empty? c) res
    (when (> (first c) res)
      (recur (rest c) (first c))
      (recur (rest c) res)))))))

(define ::T fib (::T _n)
  (loop (n _n a 1 b 0)
    (when (= n 0)
      b (recur (dec n) (+ a b) a))))
)

(define ::long[] divisors (::long l)
  (loop (::long[] res []
         n (>> l (ll "1L")))
    (when (= n 0) res
    (when (= (% l n) 0)
        (recur (append res n) (dec n))
        (recur res (dec n))))))

(define ::long sum-of-divisors (::long l)
  (loop (::long res 0 n (/ l 2))
    (when (= n 0) res
    (when (= (% l n) 0)
      (recur (+ res n) (dec n))
      (recur res (dec n))))))

(define ::long sum-of-divisors-1 (::long l)
  (sum (divisors l)))

(define ::double approx-euler (::long l)
    (/ 1.0 (fib l)))

