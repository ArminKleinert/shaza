(import-host "std.stdio")
(import-host "std.conv")
(import-host "std.typecons")
(import-host "std.string")
(import-host "std.algorithm")
(import-host "std.array")

; SECTION Global vars

(define ::int default-int)
(define ::uint default-uint)
(define ::long default-long)
(define ::ulong default-ulong)
(define ::bool default-bool)
(define ::float default-float)
(define ::double default-double)
(define ::string default-string "")

; SECTION Simple math

(meta (:generics [::N] :returns ::N)
  (meta (:export-as "plus")
    (define + (::N i0 ::N i1) (opcall + i0 i1)))
  (meta (:export-as "sub")
    (define - (::N i0 ::N i1) (opcall - i0 i1)))
  (meta (:export-as "mul")
    (define * (::N i0 ::N i1) (opcall * i0 i1)))
  (meta (:export-as "div")
    (define / (::N i0 ::N i1) (opcall / i0 i1)))
  (meta (:export-as "mod")
    (define % (::N i0 ::N i1) (opcall % i0 i1)))
  (meta (:export-as "inc")
    (define ++ (::N n) (+ n 1)))
  (meta (:export-as "dec")
    (define -- (::N n) (- n 1))))

; SECTION Bit-ops

(meta (:generics [::Int] :returns ::Int)
  (meta (:export-as "bit_and" :aliases [bit-and])
    (define & (::Int i0 ::Int i1) (opcall & i0 i1)))
  (meta (:export-as "bit_or" :aliases [bit-or])
    (define | (::Int i0 ::Int i1) (opcall | i0 i1)))
  (meta (:export-as "bit_xor" :aliases [bit-xor])
    (define ^ (::Int i0 ::Int i1) (opcall ^ i0 i1)))
  (meta (:export-as "bit_negate" :aliases [bit-flip])
    (define ~ (::Int i0) (opcall ~ i0)))
  (meta (:export-as "shift_left" :aliases [shl])
    (define << (::Int i0) (opcall ~ i0)))
  (meta (:export-as "shift_right" :aliases [shr])
    (define >> (::Int i0) (opcall ~ i0)))
)

; SECTION bool-ops

(meta (:returns ::bool)
  (meta (:export-as "and")
    (define && (::lazy:bool b0 ::lazy:bool b1) (llr b0 && b1))
    (define && (::lazy:bool b0 ::lazy:bool b1 ::lazy:bool b2) (llr b0 && b1 && b2)))
  (meta (:export-as "or")
    (define || (::lazy:bool b0 ::lazy:bool b1) (llr b0 || b1))
    (define || (::lazy:bool b0 ::lazy:bool b1 ::lazy:bool b1) (llr b0 || b1 || b2))
    (define || (::lazy:bool[] bs])
      (if (= (size bs) 0) (return false))
      (if (= (size bs) 1) (return (first bs)))
      (loop (_r bs) (if (first _r) (return true) (recur (rest bs))))))
  (define not (::bool b0) (llr !b0)))

; SECTION Comparisons and null-check

(meta (:returns ::bool :generics [::T])
  (meta (:export-as "eql_Q" :aliases [eql? ==])
    (define = (::T e0 ::T e1) (llr e0 == e1)))
  (meta (:export-as "ref_eql")
    (define === (::T e0 ::T e1) (llr "e0.ptr == e1.ptr")))
  (meta (:export-as "not_eql_Q" :aliases [not-eql? !=])
    (define not= (::T e0 ::T e1) (llr e0 != e1)))
  (meta (:export-as "lt_Q" :aliases [lt?])
    (define < (::T e0 ::T e1) (llr e0 < e1)))
  (meta (:export-as "le_Q" :aliases [le?])
    (define <= (::T e0 ::T e1) (llr e0 <= e1)))
  (meta (:export-as "gt_Q" :aliases [gt?])
    (define > (::T e0 ::T e1) (llr e0 > e1)))
  (meta (:export-as "ge_Q" :aliases [ge?])
    (define >= (::T e0 ::T e1) (llr e0 >= e1)))
  (define nil? (::T e) (llr "e is null"))
  (meta (:export-as "compare")
    (define ::int <=> (::T e0 ::T e1)
      (if (== e0 e1) (return 0)
      (if (< e0 e1) (return -1)
      (return 1))))))

; SECTION Concatenation and appending of arrays

(meta (:generics [::T] :returns ::T[])

(define append (::T[] coll0 ::T value)
  (llr coll0 ~ value))

(define append! (::T[] coll0 ::T value)
  (ll coll0 ~= value)
  coll0)

(define prepend (::T value ::T[] coll0)
  (llr "[value] ~ coll0"))

(define append (::T[] coll0 ::T[] coll1)
  (loop (::T[] res coll0 ::T[] _rest coll1)
    (if (empty? _rest)
      (return res)
      (recur (append coll0 (first coll1)) (rest coll1)))))

(define append! (::T[] coll0 ::T[] coll1)
  (loop (::T[] res coll0 _rest coll1)
    (if (empty? _rest)
      (return res)
      (recur (append! coll0 (first coll1)) (rest coll1))))))

; SECTION Attributes of and access to arrays

(meta (:generics [::T] :returns ::T[])

(define seq-of () (let (::T[] res []) (return res)))

(define ::size_t size (::T[] coll) (llr "coll.length"))
(define ::bool empty? (::T[] coll) (eql? (size coll) 0))

(meta (:returns ::T)
  (meta (:aliases [at nth])
    (define get (::T[] coll ::size_t index) (llr "coll[index]")))
  (define first (::T[] coll) (get coll 0))
  (define second (::T[] coll) (get coll 1))
  (define last (::T[] coll) (get coll (dec (size coll)))))
(define rest (::T[] coll) (slice coll 1))

(define resized (::T[] coll ::size_t newsize)
  (let (cc (coll-clone coll))
    (ll "cc.length = newsize;")
    cc))

(define coll-clone (::T[] coll)
  (concat (ll "seq_of!T") coll))

(define assoc! (::T[] coll ::size_t index ::T elem)
  (ll "coll[index] = elem;")
  coll)
(define assoc (::T[] coll ::size_t index ::T elem)
  (assoc! (coll-clone coll) index elem))

(define slice (::T[] coll ::size_t start)
  (llr "coll[start .. $]"))
(define slice (::T[] coll ::size_t start ::size_t end_offset)
  (llr "coll[start .. $ - end_offset]"))
)

; SECTION Tests for an array having a specific attribute

(meta (:returns ::bool :generics [::T])

(meta (:aliases [in?])
(define contains? (::T[] coll ::T value)
  (loop (::T current (first coll) ::T[] rest_ (rest coll))
    (if (eql? current value)
      (return #t)
      (recur (first rest_) (rest coll))))))

(define starts-with? (::T[] coll ::T e)
  (eql? (first coll) e))

(define starts-with? (::T[] coll ::T[] other)
  (if (lt? (size coll) (size other))
    (return #f))
  (loop (_coll0 (rest coll)
         _coll1 (rest other))
    (if (not_eql? (first _coll0) (first _coll1)) (return #f)
    (if (empty? _coll1) (return #t)
    (recur (rest _coll0) (rest _coll1))
    ))))

(define ends-with? (::T[] coll ::T e)
  (eql? (last coll) e))

(define ends-with? (::T[] coll ::T[] other)
  (if (lt? (size coll) (size other))
    (return #f)
    (let (slice-idx (- (size coll) (size other))
        sliced (slice coll slice-idx))
      (return (starts-with? sliced other)))))
)

; SECTION List operations

(meta (:returns ::T[] :generics [::T])

(define repeated (::T elem ::size_t times)
  (loop (::T[] result []
         i times)
    (if (<= i 0)
;;       (return result)
      (recur (append result elem) (-- i)))))

(define repeatedly (::T:delegate() func ::size_t times)
  (loop (::T[] result []
         i 0)
    (if (>= i times)
      (return result)
      (recur (append result (func)) (++ i)))))

(define map (::T:delegate(T) func ::T[] coll)
  (loop (::T[] result []
         ::T[] _rest coll)
    (if (empty? _rest)
      (return result)
      (recur (append result (func (first _rest)))
           (rest _rest)))))

(meta (:generics [::T ::T1])
(define ::T1 reduce (::T1:delegate(T,T1) func ::T[] coll ::T1 initval)
  (loop (::T1 result initVal
         ::T[] _rest coll)
    (if (empty? _rest)
      (return result)
      (recur (func (first _rest) result)
            (rest _rest))))))

(define remove (::bool:delegate(T) pred ::T[] coll)
  (loop (::T[] result []
         _rest coll)
    (if (empty? _rest)
      (return result)
      (if (pred (first _rest))
        (recur result (rest _rest))
        (recur (append result (first _rest)) (rest _rest))))))

(define remove (::T[] coll ::T elem)
  (remove (lambda ::bool (::T v) (= v elem))))

(define filter (::bool:delegate(T) pred ::T[] coll)
  (loop (::T[] result []
         _rest coll)
    (if (empty? _rest)
      (return result)
      (if (pred (first _rest))
        (recur (append result (first _rest)) (rest _rest))
        (recur result (rest _rest))))))

(define all? (::bool:delegate(T) pred ::T[] coll)
   (loop (_rest coll)
     (if (empty? _rest)
       (return true)
       (if (not (pred (first _rest)))
         (return #f)
         (recur result (rest _rest))))))

(define none? (::bool:delegate(T) pred ::T[] coll)
   (loop (_rest coll)
     (if (empty? _rest)
       (return true)
       (if (pred (first _rest))
         (return #f)
         (recur result (rest _rest))))))

(define any? (::bool:delegate(T) pred ::T[] coll)
   (loop (_rest coll)
     (if (empty? _rest)
       (return false)
       (if (pred (first _rest))
         (return #t)
         (recur result (rest _rest))))))

(meta (:aliases [uniq distinct])
(define uniques (::T[] coll)
  (if (< (size coll) 2) (return coll))
  (loop (::T[] sorted (sort coll)
         ::T prev (first sorted)
         ::T[] result [prev])
    (if (empty? sorted)
      (return result)
      (if (= prev (first sorted))
        (recur (rest sorted) prev result)
        (recur (rest sorted) (first sorted) (append result prev)))))))

(define sum (::T[] seq)
  (reduce
    (lambda ::T (::T l0 ::T l1) (+ l0 l1))
    seq 0))

(define bin-search (::T[] seq ::T key)
  (if (gt? (size seq) 1)
    (let (m (/ (size seq) 2))
      (if (eql? (get seq m) key)
        (return #t)
        (if (lt? key (get seq m))
          (return (bin-search (slice seq 0 m) key))
          (return (bin-search (slice seq (++ m)) key)))))
    (if (eql? (size seq) 1)
      (return (eql? (first seq) key))
      (return #f))))

(meta (:aliases [sort])
(define insertionsort (::T[] coll)
  (let (::T[] acc [])
    (isort-acc coll acc))))
    
(meta (:visibility :private)
  (define isort-acc (::T[] coll ::T[] acc)
    (if (empty? coll)
      (return acc)
      (isort-acc (rest coll) (isort-insert (first coll) acc))))

  (define isort-insert (::T elem ::T[] coll)
    (if (empty? coll)
      (return (seq-of elem))
      (if (lt? elem (first coll))
        (prepend elem coll)
        (prepend (first coll)
                (isort-insert elem (rest coll))))))

  (define qs-append (::T[] c0 ::T e ::T[] c1)
    (append (append c0 e) c1))
  )

(meta (:export-as "quicksort")
(define q-sort (::T[] coll)
  (if (empty? coll)
    (return coll)
    (let (piv (first coll))
      (return
        (qs-append
          (filter (lambda ::T (::T x) (<= x piv)) coll)
          piv)
          (filter (lambda ::T (::T x) (> x piv)) coll))))))

(define ::T min (::T[] coll)
  (if (= (size coll) 0) (return (llr "T.init")))
  (if (= (size coll) 1) (return (first coll)))
  (loop (::T[] c (rest coll)
         ::T res (first coll))
    (if (empty? c) (return res)
    (if (< (first c) res)
      (recur (rest c) (first c))
      (recur (rest c) res)))))

(define ::T max (::T[] coll)
  (if (= (size coll) 0) (return (llr "T.init")))
  (if (= (size coll) 1) (return (first coll)))
  (loop (::T[] c (rest coll)
         ::T res (first coll))
    (if (empty? c) (return res)
    (if (> (first c) res)
      (recur (rest c) (first c))
      (recur (rest c) res)))))

(meta (:visibility :private)
  (define ::I[] (::I) ph-sort (::I[] coll)
    (if (empty? coll) (return coll))
    (let (minimum (min coll)
          maximum (max coll)
          collsize (inc (- maximum minimum))
          ::I[] holes (repeated (llr "I.init") collsize)
          ::I[] output (repeated (llr "I.init") (size coll))
      (loop (i 0
             hindex (- (at coll i) minimum))
        (assoc! holes hindex (inc (holes hindex)))
        (if (< i (size coll))
          (recur (inc i) (- (at coll (inc i)) minimum))))

      (loop (i 0  count 0)
        (if (< count collsize)
          (let ()
            (loop ()
              (if (> (at holes count) 0)
                (let ()
                  (assoc! holes count (dec (at holes count)))
                  (assoc! coll i (+ count minimum))
                  (setv! i (inc i))
                  (recur))))
            (recur i (inc count)))))

      (return coll)))))
)

(define ::byte pidgeonhole-sort (::byte[] coll) (ph-sort coll))
(define ::short pidgeonhole-sort (::short[] coll) (ph-sort coll))
(define ::int pidgeonhole-sort (::int[] coll) (ph-sort coll))
(define ::long pidgeonhole-sort (::long[] coll) (ph-sort coll))
(define ::ubyte pidgeonhole-sort (::ubyte[] coll) (ph-sort coll))
(define ::ushort pidgeonhole-sort (::ushort[] coll) (ph-sort coll))
(define ::uint pidgeonhole-sort (::uint[] coll) (ph-sort coll))
(define ::ulong pidgeonhole-sort (::ulong[] coll) (ph-sort coll))
(define ::size_t pidgeonhole-sort (::size_t[] coll) (ph-sort coll))



; SECTION Type convertions

(define ::string (::T) to_s (::T e) (llr "to!string(" e ")"))

(ll "bool canConvert(toType, fromType)(fromType e) {
import std.conv;
try { to!toType(e); return true;
} catch(ConvException ce) { return false; }}")

; TODO All of the below should be implemented as a macro in the future.
(meta (:returns ::bool :generics [::T])
  (define to-int-valid? (::T e) (llr "canConvert!int(e)"))
  (define to-uint-valid? (::T e) (llr "canConvert!uint(e)"))
  (define to-long-valid? (::T e) (llr "canConvert!long(e)"))
  (define to-ulong-valid? (::T e) (llr "canConvert!ulong(e)"))
  (define to-float-valid? (::T e) (llr "canConvert!float(e)"))
  (define to-double-valid? (::T e) (llr "canConvert!double(e)"))
)

(define ::long[] divisors (::long l)
  (loop (::long res []
         n (>> l 1))
    (if (= n 0) (return res)
    (if (= (% l n) 0) 
        (recur (append res n) (dec n))
        (recur res (dec n))))))

(define ::long sum-of-divisors (::long l)
  (loop (::long res 0 n (/ l 2))
    (if (= n 0) (return res)
    (if (= (% l n) 0) 
      (recur (+ res n) (dec n))
      (recur res (dec n))))))

(define ::long sum-of-divisors-1 (::long l)
  (sum (divisors l)))

(define ::T (T) fib (::T _n)
  (loop (n _n
         a 1
         b 0)
    (if (= n 0)
      (return b)
      (recur (dec n) (+ a b) a))))

(define ::double approx-euler (::long l)
    (/ 1 (fib l)))

(comment
- Tokenization as always
- Build AST
- Traverse top-level AST for functions/variables (define, define-fn), structs (def-struct), meta (meta), shaza-imports (sz-import) and macros (def-macro)
  - For meta, do usual parsing for meta and functions, but write no output; Save info in global
  - For functions, save in global, write no output
  - For macros, save in global, write to separate file
  - For structs, save in global
  - For import, read, tokenize and build AST, then put AST where the import was
- Run macro-file on AST (leave macros out?) (-> Output???)
- Find function calls. If a function is specified to take varargs, put those into a typed list.
- Parse as usual
- Write output
- Run

FIXME-List
- Currently, only one function can be saved under the same name (it still works but might be a problem later)
)



