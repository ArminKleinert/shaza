(import-host "std.stdio")
(import-host "std.conv")
(import-host "std.typecons")
(import-host "std.string")
(import-host "std.algorithm")
(import-host "std.array")

; SECTION Global vars

(define ::int default-int)
(define ::uint default-uint)
(define ::long default-long)
(define ::ulong default-ulong)
(define ::bool default-bool)
(define ::float default-float)
(define ::double default-double)
(define ::string default-string "")

; SECTION Simple math

(define ::N (N) inc (::N n) (llr n + 1))
(define ::N (N) dec (::N n) (llr n - 1))
(define ::Num (Num) add (::Num i0 ::Num i1) (opcall + i0 i1))
(define ::Num (Num) plus (::Num i0 ::Num i1) (opcall + i0 i1))
(define ::Num (Num) sub (::Num i0 ::Num i1) (opcall - i0 i1))
(define ::Num (Num) minus (::Num i0 ::Num i1) (opcall + i0 i1))
(define ::Num (Num) mul (::Num i0 ::Num i1) (opcall * i0 i1))
(define ::Num (Num) div (::Num i0 ::Num i1) (opcall / i0 i1))
(define ::Num (Num) mod (::Num i0 ::Num i1) (opcall % i0 i1))

; SECTION Bit-ops

(define ::Integral (Integral) (bit-and ::Integral i0 ::Integral i1)
    (opcall & i0 i1))
(define ::Integral (Integral) (bit-or ::Integral i0 ::Integral i1)
    (opcall | i0 i1))
(define ::Integral (Integral) (bit-xor ::Integral i0 ::Integral i1)
    (opcall ^ i0 i1))

; SECTION bool-ops

(comment Not yet. Implement when lazy arguments are implemented.
    (define ::bool (and ::bool b0 ::bool b1) (llr b0 && b1))
    (define ::bool (or ::bool b0 ::bool b1) (llr b0 || b1))
    (define ::bool (not ::bool b0) (llr !b0))
)

; SECTION Comparisons and null-check

(define ::bool (T) eql? (::T e0 ::T e1) (llr e0 == e1))
(define ::bool (T) not_eql? (::T e0 ::T e1) (llr e0 != e1))
(define ::bool (T) lt? (::T e0 ::T e1) (llr e0 < e1))
(define ::bool (T) le? (::T e0 ::T e1) (llr e0 <= e1))
(define ::bool (T) gt? (::T e0 ::T e1) (llr e0 > e1))
(define ::bool (T) ge? (::T e0 ::T e1) (llr e0 >= e1))
(define ::bool (T) nil? (::T e) (llr "e is null"))

(define ::int (T) compare (::T e0 ::T e1)
    (if (eql? e0 e1) (return 0)
    (if (lt? e0 e1) (return -1)
    (return 1))))

; SECTION Concatenation and appending of arrays

(define ::T[] (T) concat (::T[] coll0 ::T[] coll1) (llr coll0 ~ coll1))
(define ::T[] (T) append (::T[] coll0 ::T value) (llr coll0 ~ value))

(define ::T[] (T) concat! (::T[] coll0 ::T[] coll1)
    (ll coll0 ~= coll1)
    coll0)
(define ::T[] (T) append! (::T[] coll0 ::T value)
    (ll coll0 ~= value)
    coll0)

; SECTION Attributes of and access to arrays

(define ::size_t (T) size (::T[] coll) (llr "coll.length"))
(define ::bool (T) empty? (::T[] coll) (eql? (size coll) 0))

(define ::T (T) get (::T[] coll ::size_t index) (llr "coll[index]"))
(define ::T (T) at (::T[] coll ::size_t index) (get coll index))
(define ::T (T) first (::T[] coll) (get coll 0))
(define ::T (T) second (::T[] coll) (get coll 1))
(define ::T (T) last (::T[] coll) (get coll (dec (size coll))))
(define ::T[] (T) rest (::T[] coll) (slice coll 1))

(define ::T[] (T) slice (::T[] coll ::size_t start)
    (llr "coll[start .. $]"))
(define ::T[] (T) slice (::T[] coll ::size_t start ::size_t end_offset)
    (llr "coll[start .. $ - end_offset]"))

; SECTION Tests for an array having a specific attribute

(define ::bool (T) contains? (::T[] coll ::T value)
    (loop (::T current (first coll) ::T[] rest_ (rest coll))
        (if (eql? current value)
            (return true)
            (recur (first rest_) (rest coll)))))

; Nicer-looking version of contains
(define ::bool (T) in? (::T[] coll ::T val)
    (contains? coll val))

(define ::bool string_start_with? (::string s ::char c)
    (eql? (first s) c))

(define ::bool (T) starts-with? (::T[] coll ::T e)
    (eql? (first coll) e))

(define ::bool (T) starts-with? (::T[] coll ::T[] other)
    (if (lt? (size coll) (size other))
        (return false))
    (loop (firstC (first coll)
           firstO (first other)
           restC (rest coll)
           restO (rest other))
      (if (not_eql? firstC firstO) (return false)
      (if (empty? restO) (return true)
      (recur (first restC) (first restO) (rest restC) (rest restO))
      )))))

(define ::bool (T) ends-with? (::T[] coll ::T e)
    (eql? (last coll) e))

(define ::bool (T) ends-with? (::T[] coll ::T[] other)
    (if (lt? (size coll) (size other))
        (return false)
        (let (slice-idx (sub (size col) (size other))
              sliced (slice coll slice-idx))
            (return (starts-with? sliced other)))))

; SECTION Type convertions

(define ::string (T) to_s (::T e) (llr "to!string(" e ")"))

(ll "bool canConvert(toType, fromType)(fromType e) {
import std.conv;
try { to!toType(e); return true;
} catch(ConvException ce) { return false; }}")

; TODO All of the below should be implemented as a macro in the future.
(define ::bool (T) to-int-valid? (::T e) (llr "canConvert!int(e)"))
(define ::bool (T) to-uint-valid? (::T e) (llr "canConvert!uint(e)"))
(define ::bool (T) to-long-valid? (::T e) (llr "canConvert!long(e)"))
(define ::bool (T) to-ulong-valid? (::T e) (llr "canConvert!ulong(e)"))
(define ::bool (T) to-float-valid? (::T e) (llr "canConvert!float(e)"))
(define ::bool (T) to-double-valid? (::T e) (llr "canConvert!double(e)"))
