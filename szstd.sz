(import-host "std.stdio")
(import-host "std.conv")
(import-host "std.typecons")
(import-host "std.string")
(import-host "std.algorithm")
(import-host "std.array")

; SECTION Global vars

(define ::int default-int)
(define ::uint default-uint)
(define ::long default-long)
(define ::ulong default-ulong)
(define ::bool default-bool)
(define ::float default-float)
(define ::double default-double)
(define ::string default-string "")

; SECTION Simple math

(define ::N (N) inc (::N n) (llr n + 1))
(define ::N (N) dec (::N n) (llr n - 1))
(define ::Num (Num) add (::Num i0 ::Num i1) (opcall + i0 i1))
(define ::Num (Num) plus (::Num i0 ::Num i1) (opcall + i0 i1))
(define ::Num (Num) sub (::Num i0 ::Num i1) (opcall - i0 i1))
(define ::Num (Num) minus (::Num i0 ::Num i1) (opcall + i0 i1))
(define ::Num (Num) mul (::Num i0 ::Num i1) (opcall * i0 i1))
(define ::Num (Num) div (::Num i0 ::Num i1) (opcall / i0 i1))
(define ::Num (Num) mod (::Num i0 ::Num i1) (opcall % i0 i1))

; SECTION Bit-ops

(define ::Integral (Integral) (bit-and ::Integral i0 ::Integral i1)
  (opcall & i0 i1))
(define ::Integral (Integral) (bit-or ::Integral i0 ::Integral i1)
  (opcall | i0 i1))
(define ::Integral (Integral) (bit-xor ::Integral i0 ::Integral i1)
  (opcall ^ i0 i1))

; SECTION bool-ops

(define ::bool (and ::lazy:bool b0 ::lazy:bool b1) (llr b0 && b1))
(define ::bool (or ::lazy:bool b0 ::lazy:bool b1) (llr b0 || b1))
(define ::bool (not ::lazy:bool b0) (llr !b0))

; SECTION Comparisons and null-check

(define ::bool (T) eql? (::T e0 ::T e1) (llr e0 == e1))
(define ::bool (T) not_eql? (::T e0 ::T e1) (llr e0 != e1))
(define ::bool (T) lt? (::T e0 ::T e1) (llr e0 < e1))
(define ::bool (T) le? (::T e0 ::T e1) (llr e0 <= e1))
(define ::bool (T) gt? (::T e0 ::T e1) (llr e0 > e1))
(define ::bool (T) ge? (::T e0 ::T e1) (llr e0 >= e1))
(define ::bool (T) nil? (::T e) (llr "e is null"))

(define ::int (T) compare (::T e0 ::T e1)
  (if (eql? e0 e1) (return 0)
  (if (lt? e0 e1) (return -1)
  (return 1))))

; SECTION Concatenation and appending of arrays

(define ::T[] (T) append (::T[] coll0 ::T value) (llr coll0 ~ value))

(define ::T[] (T) append! (::T[] coll0 ::T value)
  (ll coll0 ~= value)
  coll0)

(define ::T[] (T) prepend (::T value ::T[] coll0)
  (llr "[value] ~ coll0"))

(define ::T[] (T) concat (::T[] coll0 ::T[] coll1)
  (loop (::T[] res coll0 _rest coll1)
    (if (empty? _rest)
      (return res)
      (recur (append coll0 (first coll1)) (rest coll1)))))

(define ::T[] (T) concat! (::T[] coll0 ::T[] coll1)
  (loop (::T[] res coll0 _rest coll1)
    (if (empty? _rest)
      (return res)
      (recur (append! coll0 (first coll1)) (rest coll1)))))

; SECTION Attributes of and access to arrays

(define ::T[] (T) seq-of () (let (::T[] res []) (return res)))

(define ::size_t (T) size (::T[] coll) (llr "coll.length"))
(define ::bool (T) empty? (::T[] coll) (eql? (size coll) 0))

(define ::T (T) get (::T[] coll ::size_t index) (llr "coll[index]"))
(define ::T (T) at (::T[] coll ::size_t index) (get coll index))
(define ::T (T) first (::T[] coll) (get coll 0))
(define ::T (T) second (::T[] coll) (get coll 1))
(define ::T (T) last (::T[] coll) (get coll (dec (size coll))))
(define ::T[] (T) rest (::T[] coll) (slice coll 1))

(define :T[] (T) coll-clone (::T[] coll)
  (concat (ll "seq_of!T" coll)))

(define ::T[] (T) assoc! (::T[] coll ::size_t index ::T elem)
  (ll "coll[index] = elem;")
  coll)
(define ::T[] (T) assoc (::T[] coll ::size_t index ::T elem)
  (assoc! (coll-clone coll) index elem))

(define ::T[] (T) slice (::T[] coll ::size_t start)
  (llr "coll[start .. $]"))
(define ::T[] (T) slice (::T[] coll ::size_t start ::size_t end_offset)
  (llr "coll[start .. $ - end_offset]"))

; SECTION Tests for an array having a specific attribute

(define ::bool (T) contains? (::T[] coll ::T value)
  (loop (::T current (first coll) ::T[] rest_ (rest coll))
    (if (eql? current value)
      (return true)
      (recur (first rest_) (rest coll)))))

; Nicer-looking version of contains
(define ::bool (T) in? (::T[] coll ::T val)
  (contains? coll val))

(define ::bool string_start_with? (::string s ::char c)
  (eql? (first s) c))

(define ::bool (T) starts-with? (::T[] coll ::T e)
  (eql? (first coll) e))

(define ::bool (T) starts-with? (::T[] coll ::T[] other)
  (if (lt? (size coll) (size other))
    (return false))
  (loop (firstC (first coll)
       firstO (first other)
       restC (rest coll)
       restO (rest other))
    (if (not_eql? firstC firstO) (return false)
    (if (empty? restO) (return true)
    (recur (first restC) (first restO) (rest restC) (rest restO))
    )))))

(define ::bool (T) ends-with? (::T[] coll ::T e)
  (eql? (last coll) e))

(define ::bool (T) ends-with? (::T[] coll ::T[] other)
  (if (lt? (size coll) (size other))
    (return false)
    (let (slice-idx (sub (size col) (size other))
        sliced (slice coll slice-idx))
      (return (starts-with? sliced other)))))

; SECTION List operations

(define ::T[] (T) seq-of (::T elem)
  (llr "[elem]"))

(define ::T[] (T) map (::delegate:T(T) func ::T[] coll)
  (loop (::T[] result []
         ::T[] _rest coll)
    (if (empty? _rest)
      (return result)
      (recur (append result (func (first _rest)))
           (rest _rest)))))

(define ::TOUT (TOUT, TIN) reduce (::delegate:TOUT(TIN, TOUT) func ::T[] coll ::TOUT initval)
  (loop (::TOUT result initVal
         ::T[] _rest coll)
    (if (empty? _rest)
      (return result)
      (recur (func (first _rest) result)
            (rest _rest)))))

(define ::T[] (T) remove (::delegate:bool(T) pred ::T[] coll)
  (loop (::T[] result []
         _rest coll)
    (if (empty? _rest)
      (return result)
      (if (pred (first _rest))
        (recur result (rest _rest))
        (recur (append result (first _rest)) (rest _rest))))))

(define ::T[] (T) filter (::delegate:bool(T) pred ::T[] coll)
  (loop (::T[] result []
         _rest coll)
    (if (empty? _rest)
      (return result)
      (if (pred (first _rest))
        (recur (append result (first _rest)) (rest _rest))
        (recur result (rest _rest))))))

(comment
def bin_search(key, seq):
    if len(seq) > 1:
        m = len(seq) // 2
        if seq[m] == key:
            return True
        elif key < seq[m]:
            return bin_search(key, seq[0:m])
        else:
            return bin_search(key, seq[(m + 1):])
    elif len(seq) == 1:
        return seq[0] == key
    else:
        return False
)

(define ::T[] (T) insertionsort (::T[] coll)
  (let (::T[] acc [])
    (isort-acc coll acc)))

(define ::T[] (T) isort-acc (::T[] coll ::T[] acc)
  (if (empty? coll)
    (return acc)
    (isort-acc (rest coll) (isort-insert (first coll) acc))))

(define ::T[] (T) isort-insert (::T elem ::T[] coll)
  (if (empty? coll)
    (return (seq-of elem))
    (if (lt? elem (first coll))
      (prepend elem coll)
      (prepend (first coll)
               (isort-insert elem (rest coll))))))





; SECTION Type convertions

(define ::string (T) to_s (::T e) (llr "to!string(" e ")"))

(ll "bool canConvert(toType, fromType)(fromType e) {
import std.conv;
try { to!toType(e); return true;
} catch(ConvException ce) { return false; }}")

; TODO All of the below should be implemented as a macro in the future.
(define ::bool (T) to-int-valid? (::T e) (llr "canConvert!int(e)"))
(define ::bool (T) to-uint-valid? (::T e) (llr "canConvert!uint(e)"))
(define ::bool (T) to-long-valid? (::T e) (llr "canConvert!long(e)"))
(define ::bool (T) to-ulong-valid? (::T e) (llr "canConvert!ulong(e)"))
(define ::bool (T) to-float-valid? (::T e) (llr "canConvert!float(e)"))
(define ::bool (T) to-double-valid? (::T e) (llr "canConvert!double(e)"))
