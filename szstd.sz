(import-host "std.stdio")
(import-host "std.conv")
(import-host "std.typecons")
(import-host "std.string")
(import-host "std.algorithm")
(import-host "std.array")

(define ::N (N) inc (::N n) (llr n + 1))
(define ::N (N) dec (::N n) (llr n - 1))

(define ::Num (Num) add (::Num i0 ::Num i1) (opcall + i0 i1))
(define ::Num (Num) plus (::Num i0 ::Num i1) (opcall + i0 i1))
(define ::Num (Num) sub (::Num i0 ::Num i1) (opcall - i0 i1))
(define ::Num (Num) minus (::Num i0 ::Num i1) (opcall + i0 i1))
(define ::Num (Num) mul (::Num i0 ::Num i1) (opcall * i0 i1))
(define ::Num (Num) div (::Num i0 ::Num i1) (opcall / i0 i1))
(define ::Num (Num) mod (::Num i0 ::Num i1) (opcall % i0 i1))

(define ::Integral (Integral) (bit-and ::Integral i0 ::Integral i1)
    (opcall & i0 i1))
(define ::Integral (Integral) (bit-or ::Integral i0 ::Integral i1)
    (opcall | i0 i1))
(define ::Integral (Integral) (bit-xor ::Integral i0 ::Integral i1)
    (opcall ^ i0 i1))

(comment Not yet. Implement when lazy arguments are implemented.
    (define ::bool (and ::bool b0 ::bool b1) (llr b0 && b1))
    (define ::bool (or ::bool b0 ::bool b1) (llr b0 || b1))
    (define ::bool (not ::bool b0) (llr !b0))
)

(define ::bool (T) eql? (::T e0 ::T e1) (llr e0 == e1))
(define ::bool (T) not_eql? (::T e0 ::T e1) (llr e0 != e1))
(define ::bool (T) lt? (::T e0 ::T e1) (llr e0 < e1))
(define ::bool (T) le? (::T e0 ::T e1) (llr e0 <= e1))
(define ::bool (T) gt? (::T e0 ::T e1) (llr e0 > e1))
(define ::bool (T) ge? (::T e0 ::T e1) (llr e0 >= e1))

(define ::bool (T) nil? (::T e) (llr "e is null"))

(define ::T[] (T) concat (::T[] coll0 ::T[] coll1) (llr coll0 ~ coll1))
(define ::T[] (T) append (::T[] coll0 ::T value) (llr coll0 ~ value))

(define ::T[] (T) concat! (::T[] coll0 ::T[] coll1)
    (ll coll0 ~= coll1)
    coll0)
(define ::T[] (T) append! (::T[] coll0 ::T value)
    (ll coll0 ~= value)
    coll0)

(define ::size_t (T) size (::T[] coll) (llr "coll.length"))
(define ::T (T) get (::T[] coll ::size_t index) (llr "coll[index]"))
(define ::T (T) at (::T[] coll ::size_t index) (get coll index))
(define ::T (T) first (::T[] coll) (get coll 0))
(define ::T (T) second (::T[] coll) (get coll 1))
(define ::T (T) last (::T[] coll) (get coll (dec (size coll))))

(define ::T[] (T) slice (::T[] coll ::size_t start)
    (llr "coll[start .. $]"))
(define ::T[] (T) slice (::T[] coll ::size_t start ::size_t end_offset)
    (llr "coll[start .. $ - end_offset]"))

(comment
    (define ::T[] (T) map (::"T delegate(T elem)" func ::T[] coll)
        (t-let [::T[] outcoll []]
        (reduce
            (lambda (elem outcoll) (append outcoll (func elem)))
            coll
            outcoll)))
)

(comment
    (define ::T1 (T T1) reduce (::"T1 delegate(T curr, T1 res)" func ::T[] coll ::T1 initVal)
        (ll
            "T1 output = initVal; foreach (current; coll) { output = func(current, output); } return output;"
            ))
)

(define ::bool (T) contains (::T[] coll ::T value)
    (loop (::T current ::T[] rest_)
        (if (eql? current value)
            (return true)
            (recur (first rest_) (rest coll)))))

(define ::bool string_include? (::string s ::char c)
    (contains s c))

(define ::bool string_start_with? (::string s ::char c)
    (eql? (first s) c))

(define ::char ch (::string s ::size_t pos)
  (get s pos))

(define ::char ch (::string s)
  (first s))

(define ::bool string_end_with? (::string s ::char c)
    (eql? (last s) c))

(define ::string (T) to_s (::T e) (llr "to!string(" e ")"))


